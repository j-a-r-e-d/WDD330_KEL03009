<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Week 04 - Notes</title>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@200;300;400;600;700;800;900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="../../styles.css" />
  </head>
  <body>
    <h1>NOTES</h1>
    <h2>WDD 330 portfolio</h2>
    <h3>Week04</h3>
    <ul>
      <li><a href="../index.html">Go back to Week 04 folder</a></li>
      <li>
        <a href="main.html">Lesson Examples</a>
      </li>
      <li>
        <ol>
          <li>
            <h3>Forms</h3>
            <ul>
              <li>The <b>autofocus attribute</b> give focus to this element when a page loads. It is the
equivalent to putting the following line of JavaScript in main.js:<pre> document.forms.hero.heroName.focus();</pre> Instead, use autofocus like so:<pre>&lt;input type='text' id='heroName' name='heroName' <b>autofocus</b> placeholder='Your Super Hero Name' maxlength=32&gt;</pre> </li>
            <li>
              <b>Types of INPUT:</b>
              <ol>
                <li>
                  <b>Text:</b> This is the default input type.
                </li>
                <li>
                  <b>Password:</b> This works in the same way as an input field with type='text', except the characters are concealed as they are entered so they’re unable to be read on the screen.
                </li>
                <li>
                  <b>Checkbox:</b> Check boxes are created using input fields with type='checkbox'. They are used to select different options that can be checked (true) or left unchecked (false). The user can select more than one checkbox from a list.<br><br>
                  Make all the checkbox elements have the same 'name' property of 'powers'. This means they can be accessed as an <b>HTML collection</b>, like so:  <code>form.powers;</code>.<br>
                  The state of the checkbox can be set with HTML:<pre>&lt;input type='checkbox' value='Flight' name='powers' <b>checked</b>&gt;</pre>
                </li>
                <li>
                  <b>Radio:</b> Like checkboxes they allow users to check an option as true, but they provide an exclusive choice of options, <b>so only one option can be selected.</b> Give radio buttons the <b>same name attribute</b>. This is used to group them together ― <b>only one radio button can be checked in a group that has the same name attribute.</b> It also means we can access an HTML collection of all the radio buttons in that group using the property of the same name ― as can be seen in this line of code:<pre>form.category;</pre>
                </li>
              </ol>
            </li>
            </ul>
          </li>
          <li>
            <h3>Object Oriented Programming</h3>
            <ul>
              <li>
                3 main OOP concepts: <b>Encapsulation, Inheritance, Polymorphism.</b>
              </li>
              <li>
                <b>Encapsulation:</b> Involves keeping all the programming logic inside an object and making methods available to implement the functionality, without the outside world needing to know how it’s done.
              </li>
              <li>
                <b>Inheritance:</b> Various objects can share the same method, but also have the ability to override shared methods with a more specific implementation.
              </li>
              <li>
                <b>Polymorphism:</b> Means we can take an object that already exists and inherit all its properties and methods. We can then improve on its functionality by adding new properties and methods.
              </li>
              <li>
                <b>Prototype-based language:</b> A language, like JavaScript, that uses actual objects as the blueprint for creating more objects.
              </li>
              <li>
                <b>OBJECTS:</b> Week 3 discussed JavaScript objects. They can be created as <em>literals</em>. <br><b>An object literal is an object that is created directly in the language by wrapping all its properties and methods in curly braces {}. </b><br>Object literals are a distinguishing feature of the JavaScript language, as they allow objects to be created quickly without the need for defining a class. Example: <pre>const superman = {
name: 'Superman',
'real name': 'Clark Kent',
height: 75,
weight: 235,
hero: true,
villain: false,
allies: ['Batman','Supergirl','Superboy'], fly() {
return 'Up, up and away!'; }
};</pre> Create an empty object literal <b><span style="color:lime;">RECOMMENDED METHOD</span></b>: <pre>const spiderman = {};</pre> Create an empty object literal using a constructor function <b>NOT RECOMMENDED</b>: <pre>const spiderman = new Object();</pre>
              </li>
              <li>
                <b>Class Declaration Syntax Example:</b> <pre>class Dice { constructor(sides=6) { this.sides = sides;
}
roll() {
return Math.floor(this.sides * Math.random() + 1) }
}</pre>
              </li>
              <li>
                <B>STATIC KEYWORD:</B> Adding <em>static</em> before a class method name (ex. <code>static</code> description(){return 'This is an example of a static method.'}) makes it only available to the class directly, not instances of the class. So a dice class could call Dice.description but not an instance of Dice class, like blueDice.Description - <b>[ERROR!]</b> 
              </li>
              <li>
                <b>PROTOTYPES:</b> Watch this <a href="https://www.youtube.com/watch?v=01jVgCK-HX4" target="_blank">video</a>  to see a good explanation of Prototypes.
                <h4>Point to remember:</h4>
                <ol>
                  <li>
                    In Javascript, <b>every function has a prototype object built-into it</b>. For example, a class' Constructor is a function. It thus has a Prototype object associated with it (it can be accessed with the dunder-proto [meaning <em>double underscore</em>]) <b>__proto__</b>.
                  </li>
                </ol>
              </li>
              <li>
                <b>PRIVATE vs PUBLIC:</b> By default, JavaScript class properties and methods are PUBLIC. However, if you want to mave PRIVATE methods and properties, use <em>getters and setters</em> like so:<pre>class Turtle {
constructor(name,color) {
this.name = name;
let _color = color;
this.setColor = color => { return _color = color; } 
this.getColor = () => _color;
}
}</pre> Using <em>getters and setters</em> will allow you to validate data/input before changes are made. The SETTER function above could have a check like so to ensure that only strings are used as input:<pre>this.setColor = (color) => { 
  if(typeof color === 'string'){
    return _color = color;
  } else {
    throw new Error('Color must be a string'); 
  }
}</pre>
              </li>
              <li>
                <b>Enumerable Properties:</b><br>
                If an object's properties are <em>enumerable</em> then they can be seen by using a 'for-in' loop. By keeping all Object() properties and methods non-enumberable (i.e. toString() method), they won't be flooding the results for a user who is trying to find the specific methods and properties to a user-defined object.<br>
                To find out if a method or property is enumerable use: <b>Turtle.prototype.propertyIsEnumerable('eat');</b>
              </li>
              <li>
                To create a <b>sub-class or child class</b> which inherits all the properties and methods of a parent class, use the <em><code>extends</code></em> keyword like so:<pre>class NinjaTurtle extends Turtle {
  constructor(name) {
    super(name);
    this.weapon = 'hands'; 
  }
  attack() { return `Feel the power of my ${this.weapon}!` } 
}</pre>Inside the child class declaration, the keyword <b><code>super</code></b> refers to the parent class, and can be used to access any properties and call any methods of the parent class. In the example above we use it to call the constructor function of the Turtle class.
              </li>
              <li>
                It’s possible to avoid using classes altogether, and create new objects based on another object that acts as a blueprint or prototype instead.<br>
                The <b>Object() constructor</b> function has a method called create that can be used to create a new object that is an exact copy of the object that is provided as an argument. The object that is provided as the argument acts as the prototype for the new object. EX: Create an object:<pre>const Human = {
arms: 2,
legs: 2,
walk() { console.log('Walking'); } 
}</pre>Then create an instance of that object using the <code>Object.create()</code> method:<pre>const lois = Object.create(Human);</pre><br>
              Since Prototypal Objects aren't the same as Classes, instead of Constructors, one must use a custom <code>init</code> method like so:<pre>Superhuman.init = function(name,realName){ 
    this.name = name;
    this.realName = realName;
    this.init = undefined; // this line removes the init function, so it can only be called once
  return this;
}</pre>
              </li>
              <li>
                <B>OBJECT PROTOTYPE CHAIN</B><br>
                <b>Creating objects from objects will create a prototype chain.</b>
              </li>
              <li>
                <b>MIXIN:</b><br>
                A mixin is a way of adding properties and methods of some objects to another object without using inheritance. It allows more complex objects to be created by ‘mixing’ basic objects together.
              </li>
              <li>
                <b id="chaining">CHAINING FUNCTIONS:</b>
                <p>
                  If a method returns this, its methods can be chained together to form a sequence of method calls that are called one after the other. For example, the superman object can call all three of the superpower methods at once:<pre>superman.fly().move().xray();</pre>A big drawback with this technique is that it can make code more difficult to debug. If an error is reported as occurring on a particular line, there is no way of knowing which method caused the error, since there are multiple method calls on that line.<br><br>It’s worth keeping in mind that if a method lacks a meaningful return value, it might as well return this so that chaining is possible.
                </p>
              </li>
            </ul>
          </li>
          <li>
            <h3>MODULAR JAVASCRIPT</h3>
            <UL>
              <li>
                <b>IMPORT / EXPORT</b>:<br>
                To export JS code, write your modularized code in a separate file and include 'export' in it like so:<br>(Export Example)<pre>export const PI = 3.1415926;</pre>The, in your main.js file, import it like so:<br>(Import example)<pre>import { PI } from './pi.js';</pre>
                If you want to <b>import all methods</b> and properties that are available from a file, do the following:<pre>import * as stats from './stats.js';</pre>
                This will then import all the functions from the stats.js module and they’ll be given a namespace of stats. So, the mean function could be used as follows:<pre>stats.mean([2,6,10]);</pre>
              </li>
              <li>
                <b>MVC - Model-View-Controller</b>: MVC separates an application into three distinct, independent components that interact with each other:
                <ol>
                  <li>
                    <b>Models</b> are objects that implement the functionality for creating, reading, updating and deleting (known as CRUD tasks) specific pieces of information about the application, as well as any other associated logic and behavior. In a to-do list application, for example, there would be a task model providing methods to access all the information about the tasks such as names, due dates and completed tasks. This data will often be stored in a database or some other container.
                  </li>
                  <li>
                    <b>Views</b> provide a visual representation of the model showing all the relevant information. <b>In a web application, this would be the HTML displayed on a web page.</b> Views also provide a way for users to interact with an application, usually via forms. In a to-do list application, the views would display the tasks as an HTML list with checkboxes that a user could tick to say a task had been completed.
                  </li>
                  <li>
                    <b>Controllers</b> link models and views together by communicating between them. They respond to events, which are usually inputs from a user (entering some data into a form, for example), process the information, then update the model and view accordingly. In a to-do list application, the controller functions would respond to the event of a user clicking on a check box and then inform the model that a task had been completed. The model would then update the information about that task.
                  </li>
                </ol>
              </li>
            </UL>
          </li>
        </ol>
      </li>
    </ul>
  </body>
</html>
